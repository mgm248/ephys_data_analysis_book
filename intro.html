
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Analysis of Electrophysiological Data in Neuroscience</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint single-page" id="site-navigation">
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/executablebooks/jupyter-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fintro.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-0_LFP_Identifying_Oscillations">
   Identifying Oscillations
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-1_LFP_Coherence_Directionality">
   Coherence and Directionality
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-2_ST_LFP_Spike_LFP_Coupling">
   Spike-LFP Coupling
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-3_ST_SpikeTrain_Analyses">
   Spike Train Analyses
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-4_ST_Spike_Synchrony">
   Spike Synchrony
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Analysis of Electrophysiological Data in Neuroscience</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-0_LFP_Identifying_Oscillations">
   Identifying Oscillations
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-1_LFP_Coherence_Directionality">
   Coherence and Directionality
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-2_ST_LFP_Spike_LFP_Coupling">
   Spike-LFP Coupling
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-3_ST_SpikeTrain_Analyses">
   Spike Train Analyses
  </a>
 </li>
 <li class="toctree-l1 toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="intro.html#document-4_ST_Spike_Synchrony">
   Spike Synchrony
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="analysis-of-electrophysiological-data-in-neuroscience">
<h1>Analysis of Electrophysiological Data in Neuroscience<a class="headerlink" href="#analysis-of-electrophysiological-data-in-neuroscience" title="Permalink to this headline">#</a></h1>
<p>Tutorials and scripts for analyzing electrophysiological (LFP and spike train) data.</p>
<div class="toctree-wrapper compound">
<span id="document-0_LFP_Identifying_Oscillations"></span><section class="tex2jax_ignore mathjax_ignore" id="identifying-oscillations">
<h2>Identifying Oscillations<a class="headerlink" href="#identifying-oscillations" title="Permalink to this headline">#</a></h2>
<p>This notebook will show how to quantify neural oscillations. Here, from some example data, we will calculate and plot:</p>
<ol class="simple">
<li><p>Power spectrum</p></li>
<li><p>Windowed (classic) spectrogram</p></li>
<li><p>Wavelet based spectrogram</p></li>
</ol>
<section id="frequency-domain">
<h3>Frequency Domain<a class="headerlink" href="#frequency-domain" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">welch</span><span class="p">,</span> <span class="n">spectrogram</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Load in the LFP, stimulation time data</span>
<span class="n">fpath</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;C:\Users\Michael\Documents\ephys_analysis_tutorials</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">lfp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fpath</span><span class="o">+</span><span class="s1">&#39;example_lfp_160819_bank2.npy&#39;</span><span class="p">)</span>
<span class="n">stim_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fpath</span><span class="o">+</span><span class="s1">&#39;example_stim_times_160819_bank2.npy&#39;</span><span class="p">)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
</div>
</div>
<p>Here, we have lfp data (already filtered + resampled to 1000Hz) from an electrode in the olfactory bulb, recording while odors are presented. The array stim_times indicates when odors are experienced (the first inhalation after each odor presentation), for 6 different odors, formatted as odors x events.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Plot the lfp data in response to stimulation</span>
<span class="n">evt</span> <span class="o">=</span> <span class="n">stim_times</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="c1">#look at the first presentation of the first odor</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="mi">1000</span><span class="p">)]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time post odor onset (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Voltage&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_5_1.png" src="_images/0_LFP_Identifying_Oscillations_5_1.png" />
</div>
</div>
<p>We see a big deflection around 200ms, and an oscillation until a little after 600ms. Next, we’ll want to quantify the presence of this oscillation. A common first step here is to plot the power spectrum of the data.</p>
<section id="power-spectrum">
<h4>Power Spectrum<a class="headerlink" href="#power-spectrum" title="Permalink to this headline">#</a></h4>
<p>Using a Fourier transformation, any signal can be decomposed into some combination of sinusoidal oscillations. The power spectrum of a signal describes the distribution of frequency components that compose that signal. It is often used to quantify the presence of different oscillations, as a power spectrum quantifies the amplitude across frequencies.</p>
<p>More specifically, to compute a power spectrum, the autocorrelation of a signal is computed, and then the Fourier Transform of the result is taken. Though this can be computed once, across the entire signal, in practice this results in a noisy estimate of the power spectrum. Here, we’ll use Welch’s method <a class="reference external" href="#References">[1]</a> to compute power, where the signal is segmented into a series of overlapping windows, and the power spectrum of each segment are averaged. The window size and overlap are determined by the <em>nperseg</em> and <em>noverlap</em> parameters in scipy’s welch function. Feel free to mess around with these to get an idea of the tradeoffs between large and small windows, and the degree of overlap.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Pxx</span> <span class="o">=</span> <span class="n">Pxx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Power Spectral Density&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_8_1.png" src="_images/0_LFP_Identifying_Oscillations_8_1.png" />
</div>
</div>
<p>The power spectrum is much higher at lower frequencies (&lt;20Hz). This is characteristic of neural LFP data, referred to as 1/f or pink noise, where power systematically decreases with frequency. Still, we can see three peaks in power that go beyond this trend: one around 5Hz, one just below 20Hz, and another small peak around 70Hz. To better visualize this, we should remove the 1/f noise in the data. Though an <a class="reference external" href="https://fooof-tools.github.io/fooof/index.html">excellent tool</a> has been developed for this purpose, we can also remove this noise by normalizing to a baseline period, before odor presentation, where this noise will still be present. This will also help us identify which oscillations are specifically induced by the odor.</p>
<p>To do so, we’ll take the power spectrum for 1 second of data before the odor was presented, and divide the odor-evoked psd by this baseline psd. <strong>Note</strong>: Make sure your parameters match the ones you used to compute the first power spectrum, or else the frequency resolution won’t match and you won’t be able to normalize.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Pxx_evoked</span> <span class="o">=</span> <span class="n">Pxx</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">f</span><span class="p">,</span> <span class="n">Pxx_baseline</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Pxx_baseline</span> <span class="o">=</span> <span class="n">Pxx_baseline</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">Pxx_normalized</span> <span class="o">=</span> <span class="n">Pxx_evoked</span> <span class="o">/</span> <span class="n">Pxx_baseline</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx_normalized</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Power Spectral Density&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_10_1.png" src="_images/0_LFP_Identifying_Oscillations_10_1.png" />
</div>
</div>
<p>That helps a little bit: we now clearly see the peak in beta (~20Hz). There’s also a big increase in power at the lowest frequencies.</p>
<p>A power spectra is a useful first step for examining the oscillatory content of a time-series. However, we are still missing
some information. For example, here, the gamma (~70Hz) oscillation is pretty muted. One reason for this is the gamma oscillation is brief, and here we’re looking at power over the entire second, making it hard to distinguish between a brief oscillation from a weak one. To better analyze this, let’s look at how power changes over time.</p>
</section>
</section>
<section id="time-frequency-domains">
<h3>Time Frequency Domains<a class="headerlink" href="#time-frequency-domains" title="Permalink to this headline">#</a></h3>
<p>Time frequency analyses, as the name indicates, introduce a time dimension to our power analyses. This allows us to analyze when exactly oscillations are present. Now, our outputs are matrices called spectrograms, plotted as heatmaps, of power over both frequency and time.</p>
<section id="window-analysis">
<h4>Window analysis<a class="headerlink" href="#window-analysis" title="Permalink to this headline">#</a></h4>
<p>A simple and common time frequency analysis is to compute a spectrogram as a series of power spectra. Here, the data is broken up into a set of overlapping windows, and the power spectrum is computed on each of these windows. We can use scipy’s spectrogram function here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">relative_times</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span><span class="mi">1500</span><span class="p">]</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">],:]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_13_1.png" src="_images/0_LFP_Identifying_Oscillations_13_1.png" />
</div>
</div>
<p>Let’s normalize this too. Now that we have data on how our power changes over time, we get multiple samples of power data for each frequency, and we can z-score the evoked power to this distribution at baseline.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Sxx_evoked</span> <span class="o">=</span> <span class="n">Sxx</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx_baseline</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Sxx_baseline</span> <span class="o">=</span> <span class="n">Sxx_baseline</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">],:]</span> <span class="c1">#select only frequencies below 100Hz</span>

<span class="n">Sxx_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Sxx_evoked</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">for</span> <span class="n">f_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Sxx_evoked</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">Sxx_normalized</span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sxx_evoked</span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Sxx_baseline</span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Sxx_baseline</span><span class="p">[</span><span class="n">f_i</span><span class="p">,</span> <span class="p">:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Sxx_normalized</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_15_1.png" src="_images/0_LFP_Identifying_Oscillations_15_1.png" />
</div>
</div>
<p>The output here is clearly very blocky, due to the windowing procedure. There’s also a tradeoff between time resolution and frequency resolution we can explore. Here, the bigger the time window used, the finer the frequency resolution of each power spectrum, and therefore the spectrogram as a whole. However, bigger time windows decrease time resolution as well, so we can optimize the time resolution by choosing to use smaller time windows. In scipy’s spectrogram function, the length of the time segments are set by the nperseg argument, indicating the number of samples per segment. Let’s try optimizing for time or frequency resolution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="mi">1500</span><span class="p">]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">],:]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Increased time resolution&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">],:]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Increased frequency resolution&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Increased frequency resolution&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_17_1.png" src="_images/0_LFP_Identifying_Oscillations_17_1.png" />
</div>
</div>
<p>Increasing the frequency resolution, we can see power is increasing in two distinct lower frequency bands, one around 4Hz and another around 20Hz.</p>
<p>Overall, a window-based spectrogram is a straightforward way to extract oscillatory power over both time and frequency. However, the outputs here are very limited in both time and frequency resolution. When analyzing oscillations over long (&gt;10s) timescales, this is not a problem, and the results will look much better than these. However, we want to analyze oscillation power over a small time window (~1s), and so currently our time and frequency resolution is poor. To better analyze oscillation power in the time and frequency domains for this short time period, a morlet wavelet based analysis is more effective.</p>
</section>
<section id="morlet-wavelets">
<h4>Morlet wavelets<a class="headerlink" href="#morlet-wavelets" title="Permalink to this headline">#</a></h4>
<p>An alternative to a windowed fourier analysis is convolution with morlet (or Gabort) wavelets. These wavelets are themselves sinewaves weighted by a gaussian. This weighting provides temporal specificity, and convolving these wavelets with the signal allows for the measurement of power over time. To analyze power from different frequencies, wavelets are created from sinewaves of different frequencies. Spectrograms produced from morelet wavelet analysis are not “blocky” like the fourier analysis, as the gaussian weighting of the wavelets results in a gaussian spread of power over both time and frequency.</p>
<p>Fewer packages support morlet wavelet convolution. <a class="reference external" href="https://mne.tools/stable/index.html">MNE</a> is an has a <a class="reference external" href="https://mne.tools/stable/generated/mne.time_frequency.tfr_morlet.html">great function for this</a> we’ll use here. The package is a great resource for analyzing LFP data in python, though it is designed for EEG+MEG data.</p>
<p>First, let’s set up or data for mne. We need to create an info structure, and format the data into an epochs array.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mne</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">ch_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">sfreq</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">ch_types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;eeg&#39;</span><span class="p">])</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))))</span>
<span class="n">epoch</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">EpochsArray</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>When we run the morlet time-frequency analysis, we’ll need to set a the parameter n_cycles. Like fourier window analyses, morelet wavelet analyses have inputs that result in a trade-off between time and frequency resolution, namely, the length of the wavelet. Longer wavelets are less precise in time, but more precise in frequency. In MNE, the length of the wavelet is determined by the n_cycles parameter, which indicates the number of cycles in the wavelets (with frequency held constant, such that more cycles results in a longer wavelet). This can be set globally for all wavelets, resulting in the same frequency specificity across wavelets of different frequencies. Let’s try this first.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">tf_pow</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">time_frequency</span><span class="o">.</span><span class="n">tfr_morlet</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_itc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_23_1.png" src="_images/0_LFP_Identifying_Oscillations_23_1.png" />
</div>
</div>
<p>Again, we can normalize by a baseline period. MNE has an apply_baseline function on time_frequency objects we can use to here, we just need to compute the spectrogram over both the baseline and evoked periods to give the function all the data it needs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">relative_times</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span><span class="mi">1500</span><span class="p">]</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))))</span>
<span class="n">epoch</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">EpochsArray</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">tf_pow</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">time_frequency</span><span class="o">.</span><span class="n">tfr_morlet</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_itc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">tf_pow</span><span class="o">.</span><span class="n">apply_baseline</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;zscore&#39;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="mf">.2</span><span class="p">,</span> <span class="mf">1.800</span><span class="p">))</span> <span class="c1">#add a little padding for the baseline</span>
<span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Applying baseline correction (mode: zscore)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 1000.0)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_25_2.png" src="_images/0_LFP_Identifying_Oscillations_25_2.png" />
</div>
</div>
<p>This looks better, but this spectrogram still appears smeared over time at low frequencies while varying sharply at high frequencies. This is because when we set n_cycles globally, the time specificity of each wavelet will vary, as one cycle of a 2Hz oscillation takes much more time than one cycle of a 20Hz oscillation. Therefore, weighting the number of cycles of wavelets by their frequencies is often preferable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">relative_times</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span><span class="mi">1500</span><span class="p">]</span>
<span class="n">time_segment</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">evt</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span><span class="o">+</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#start and end event times of interest, converted to ms</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))))</span>
<span class="n">epoch</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp_data</span><span class="p">[</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_segment</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">EpochsArray</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">tf_pow</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">time_frequency</span><span class="o">.</span><span class="n">tfr_morlet</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">return_itc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">tf_pow</span><span class="o">.</span><span class="n">apply_baseline</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;zscore&#39;</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="mf">.2</span><span class="p">,</span> <span class="mf">1.800</span><span class="p">))</span> <span class="c1">#add a little padding for the baseline</span>
<span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">relative_times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Applying baseline correction (mode: zscore)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/0_LFP_Identifying_Oscillations_27_2.png" src="_images/0_LFP_Identifying_Oscillations_27_2.png" />
</div>
</div>
<p>Now, we can see a clear oscillation at 20Hz, and a weak oscillation around 70Hz, around 400ms post odor presentation.</p>
<p>Each of these analyses measures the power of sinusoidal oscillations. However, neural oscillations are often non-sinusoidal, and this can lead to some erroneous outputs. For example, a non-sinusoidal oscillation will often lead to spurious peaks in power at harmonic frequencies of the actual oscillation frequency. This occurs when the fourier analysis decomposes the non-sinusoidal oscillation into a sinusoidal oscillation at its true frequency, and resulting in leftover signal that can be composed from harmonics of that frequency <a class="reference external" href="#References">[2]</a></p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>P. Welch, “The use of the fast Fourier transform for the estimation of power spectra: A method based on time averaging over short, modified periodograms”, IEEE Trans. Audio Electroacoust. vol. 15, pp. 70-73, 1967.</p></li>
<li><p>Donoghue, T., Schaworonkow, N., &amp; Voytek, | Bradley. (2021). Methodological considerations for studying neural oscillations. <a class="reference external" href="https://doi.org/10.1111/ejn.15361">https://doi.org/10.1111/ejn.15361</a></p></li>
</ol>
</section>
</section>
<span id="document-1_LFP_Coherence_Directionality"></span><section class="tex2jax_ignore mathjax_ignore" id="coherence-and-directionality">
<h2>Coherence and Directionality<a class="headerlink" href="#coherence-and-directionality" title="Permalink to this headline">#</a></h2>
<p>This notebook will illustrate how to calculate the coherence between two signals, and then the directionality of information flow between two areas. Specifically, this notebook shows how to quantify:</p>
<ol class="simple">
<li><p>Coherence + phase offset in the frequecy domain</p></li>
<li><p>Coherence + phase offset in the time-frequency domains</p></li>
<li><p>Amplitude correlation</p></li>
<li><p>Phase slope index</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>
<span class="kn">import</span> <span class="nn">mne_connectivity</span>
<span class="kn">from</span> <span class="nn">mne</span> <span class="kn">import</span> <span class="n">create_info</span><span class="p">,</span> <span class="n">EpochsArray</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">hilbert</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s simulate two signals with a coherent 20Hz oscillation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">lfp1</span> <span class="o">=</span> <span class="n">osc</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">lfp2</span> <span class="o">=</span> <span class="n">osc</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x1e28e270910&gt;]
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_3_1.png" src="_images/1_LFP_Coherence_Directionality_3_1.png" />
</div>
</div>
<p>Now, let’s measure the coherence. To do so, we’ll first need to calculate the <strong>cross spectral density</strong> between the two signals. The difference between power and coherence comes down to performing an autocorrelation instead of a cross correlation. Where the autocorrelation of a signal is computed by convolving a signal with itself, a cross-correlation is computed by convolving one signal with another. The power spectral density is then the Fourier Transform of the autocorrelation, and the cross spectral density is the Fourier Transform of the cross-correlation.</p>
<p>Coherence is computed as the magnitude-squared cross spectral density, normalized by the power spectrum of each signal <a class="reference external" href="#References">[1]</a>. Therefore, coherence will be between 0 (where the two signals are completely uncorrelated) and 1 (where the two signals are perfectly correlated) at each frequency.</p>
<p>The equation for computing coherence is therefore <span class="math notranslate nohighlight">\(Coh_{xy} = \frac{|Pxy|^{2}}{Pxx*Pyy}\)</span>, where Pxx is the power spectrum of x, Pyy is the power spectrum of y, and Pxy is the cross spectrum of x and y.</p>
<p>Therefore, the power spectrum of a signal can be thought of as the coherence of a signal with itself. As a result, we can use scipy’s <em>csd</em> function both to compute the cross spectrum between x and y, and their power spectrum for computation of coherence. This function computes each spectrum using Welch’s method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">lfp1</span><span class="p">,</span> <span class="n">lfp1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
<span class="n">f</span><span class="p">,</span> <span class="n">Pyy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">lfp2</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
<span class="n">f</span><span class="p">,</span> <span class="n">Pxy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">lfp1</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
<span class="n">Coh_xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Pxx</span><span class="o">*</span><span class="n">Pyy</span><span class="p">)</span>
<span class="n">Coh_xy</span> <span class="o">=</span> <span class="n">Coh_xy</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Coh_xy</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Coherence&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_5_1.png" src="_images/1_LFP_Coherence_Directionality_5_1.png" />
</div>
</div>
<p>We can also (more conviently) use scipys <em>coherence</em> function, and obtain the same results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">coh</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">lfp1</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>
<span class="n">coh</span> <span class="o">=</span> <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">coh</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Coherence&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_7_1.png" src="_images/1_LFP_Coherence_Directionality_7_1.png" />
</div>
</div>
<p>We can also get the phase difference between the two signals at each frequency just by taking the phase of Pxy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="p">[:</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Pxy</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Phase difference (radians)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Phase difference (radians)&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_9_1.png" src="_images/1_LFP_Coherence_Directionality_9_1.png" />
</div>
</div>
<p>Because there is no phase lag between the two signals in the 20Hz oscillation, the this phase difference should be close to 0 at 20Hz, but essentially random at other frequencies.</p>
<section id="time-frequency">
<h3>Time-frequency<a class="headerlink" href="#time-frequency" title="Permalink to this headline">#</a></h3>
<p>Now, let’s try computing coherence in the time frequency domain. This is not as straightforward as computing power in the time frequency domain. Coherence is essentially a correlation measure, and to compute a correlation, you need multiple samples from each signal. Therefore, we cannot take two signals and compute their coherence at each sample. Instead, there are two common approaches to compute coherence in the time-frequency domains. The first is to compute coherence in windows over time, or after smoothing the data over time resulting in decreased resolution over time <a class="reference external" href="#References">[2]</a>. The other is to compute the coherence over trials, rather than time, allowing for an estimation of time frequency coherence without any loss of time or frequency resolution.</p>
<p>Just like for time-frequency analysis of power, we can use MNE supported time-frequency decompositon via morlet wavelets to compute time-frequency coherence. First, let’s simulate two signals where their coherence changes over time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">lfp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">lfp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">lfp1</span><span class="p">[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span>
<span class="n">lfp2</span><span class="p">[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x1e28f3ff220&gt;]
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_11_1.png" src="_images/1_LFP_Coherence_Directionality_11_1.png" />
</div>
</div>
<p>Now let’s try computing time frequency coherence over time on single trials, using MNE’s <a class="reference external" href="https://mne.tools/mne-connectivity/stable/generated/mne_connectivity.spectral_connectivity_time.html">spectral_connectivity_time</a> function. We’ll again need to format the data for mne (for this function, data must be formatted into an mne epochs structure).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">info</span> <span class="o">=</span> <span class="n">create_info</span><span class="p">(</span><span class="n">ch_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">sfreq</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">ch_types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;eeg&#39;</span><span class="p">,</span><span class="s1">&#39;eeg&#39;</span><span class="p">])</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>
<span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fs</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp2</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fs</span><span class="p">)):</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">EpochsArray</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">/</span><span class="mi">2</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">mne_connectivity</span><span class="o">.</span><span class="n">spectral_connectivity_time</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;coh&#39;</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span>
                                                                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cwt_morlet&#39;</span><span class="p">,</span> <span class="n">freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span>
                                                                        <span class="n">n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Connectivity computation...
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\Michael\AppData\Local\Temp\ipykernel_4552\2007432969.py:9: RuntimeWarning: There were no Annotations stored in &lt;EpochsArray |  1 events (all good), 0 - 1.999 sec, baseline off, ~39 kB, data loaded,
 &#39;1&#39;: 1&gt;, so metadata was not modified.
  con = mne_connectivity.spectral_connectivity_time(epochs, method=&#39;coh&#39;, sfreq=int(fs),
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "5462abe6ec564e37a1a489af10c8d686"}
</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Plot</span>
<span class="n">coh</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="n">coh</span> <span class="o">=</span> <span class="n">coh</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coh</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="c1"># TODO: plot phase on this</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_14_1.png" src="_images/1_LFP_Coherence_Directionality_14_1.png" />
</div>
</div>
<p>Now, we’ll simulate the data over many trials, and compute the coherence over trials using MNE’s <a class="reference external" href="https://mne.tools/mne-connectivity/stable/generated/mne_connectivity.spectral_connectivity_epochs.html">spectral_connectivity_epochs</a> function. This function takes a numpy array structure, rather than an mne epochs structure for its data input.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span>
<span class="n">trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">trials</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>

<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trials</span><span class="p">):</span>
    <span class="n">lfp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">lfp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">lfp1</span><span class="p">[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span> <span class="o">+=</span> <span class="n">osc</span>
    <span class="n">lfp2</span><span class="p">[</span><span class="mi">750</span><span class="p">:</span><span class="mi">1250</span><span class="p">]</span> <span class="o">+=</span> <span class="n">osc</span>
    <span class="n">epochs</span><span class="p">[</span><span class="n">trial</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lfp1</span>
    <span class="n">epochs</span><span class="p">[</span><span class="n">trial</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">lfp2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">/</span><span class="mi">2</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">mne_connectivity</span><span class="o">.</span><span class="n">spectral_connectivity_epochs</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;coh&#39;</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span>
                                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cwt_morlet&#39;</span><span class="p">,</span> <span class="n">cwt_freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span>
                                                   <span class="n">cwt_n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>                                                   
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Connectivity computation...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for 1 connections
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using t=0.000s..1.999s for estimation (2000 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    frequencies: 3.0Hz..99.0Hz (97 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using CWT with Morlet wavelets to estimate spectra
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    the following metrics will be computed: Coherence
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 3
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 6
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 7
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 10
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Connectivity computation done]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coh</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coh</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_18_1.png" src="_images/1_LFP_Coherence_Directionality_18_1.png" />
</div>
</div>
<p><strong>Phase</strong></p>
<p>Just as for coherence in frequency space, we can get the phase difference of time-frequency coherence. To do so, we first get the complex coherence values, containing both the amplitude and phase information of the coherence, by setting the method parameter of the spectral_connectivity function to ‘cohy’. We can get the amplitude of the coherence (the same metric computed originally) by taking the absolute value of this output, and the phase by taking the angle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">con_complex</span> <span class="o">=</span> <span class="n">mne_connectivity</span><span class="o">.</span><span class="n">spectral_connectivity_epochs</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cohy&#39;</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span>
                                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cwt_morlet&#39;</span><span class="p">,</span> <span class="n">cwt_freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span>
                                                   <span class="n">cwt_n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
                                                   
<span class="n">coh_complex</span> <span class="o">=</span> <span class="n">con_complex</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="n">coh_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">coh_complex</span><span class="p">)</span>
<span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coh_complex</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Connectivity computation...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for 1 connections
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using t=0.000s..1.999s for estimation (2000 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    frequencies: 3.0Hz..99.0Hz (97 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using CWT with Morlet wavelets to estimate spectra
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    the following metrics will be computed: Coherency
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 2
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 3
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 4
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 5
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 6
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 7
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 8
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 9
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 10
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Connectivity computation done]
</pre></div>
</div>
</div>
</div>
<p>We can plot both the amplitude and phase of the coherence on the same plot by plotting the phase information as a quiver plot. Since the coherence output contains data for every sample and every frequency, I select a subset of the phase values to plot.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coh</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">coh_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coh_phase</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">coh_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">coh_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">coh_phase</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">coh_phase</span><span class="p">)</span>
<span class="n">f_x</span> <span class="o">=</span> <span class="mi">160</span>
<span class="n">f_y</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="n">f_y</span><span class="p">,</span> <span class="p">::</span><span class="n">f_x</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="n">f_y</span><span class="p">,</span> <span class="p">::</span><span class="n">f_x</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="n">f_y</span><span class="p">,</span> <span class="p">::</span><span class="n">f_x</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="n">f_y</span><span class="p">,</span> <span class="p">::</span><span class="n">f_x</span><span class="p">],</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;uv&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.quiver.Quiver at 0x1e28fb93be0&gt;
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_22_1.png" src="_images/1_LFP_Coherence_Directionality_22_1.png" />
</div>
</div>
</section>
<section id="directionality">
<h3>Directionality<a class="headerlink" href="#directionality" title="Permalink to this headline">#</a></h3>
<p>If two signals (brain areas) are correlated, that could mean they both are affecting each other’s activity, or one area is primarily driving another. Therefore, after analyzing the coherence between two signals, it is often useful to analyze the directionality of any relationship between two signals. Here, I will discuss two common methods for assessing directionality in neuroscience: <strong>amplitude correlations</strong> and the <strong>phase slope index</strong>.</p>
<p>First, we’ll simulate data such that lfp2 lags lfp1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate data</span>
<span class="n">lag</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">samples</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">lfp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">lfp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">samples</span><span class="p">)</span>
<span class="n">lfp2</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="n">lfp1</span><span class="p">[:</span><span class="n">samples</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>

<span class="c1"># lfp1[750:1250] += np.sin(2 * np.pi * times[:] * 20)[0:500]</span>
<span class="c1"># lfp2[750+lag:1250+lag] += lfp1[750:1250]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;lfp2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x1e28fa36070&gt;]
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_24_1.png" src="_images/1_LFP_Coherence_Directionality_24_1.png" />
</div>
</div>
</section>
<section id="amplitude-correlation">
<h3>Amplitude Correlation<a class="headerlink" href="#amplitude-correlation" title="Permalink to this headline">#</a></h3>
<p>The amplitude correlation is a straightforward method of computing the directionality between two signals. Also referred to as a power envelope correlation <a class="reference external" href="#References">[3]</a>, the method is a cross-correlation of the amplitudes in a frequency between two signals. The first step of this method is to filter each signal in the frequency band of interest, and then compute the amplitude envelope of each by taking the hilbert transform of the filtered signal. Then a cross-correlation is performed between the two amplitude envelopes. Therefore, the amplitude correlation can indicate when the power of the oscillation is most correlated between the two signals, revealing whether an oscillation in one signal precedes or follows an oscillation in another signal.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Filter</span>
<span class="n">order</span><span class="o">=</span><span class="mi">4</span>
<span class="n">freq_band</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>
<span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">freq_band</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
<span class="n">lfp1_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">lfp1</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">lfp2_filt</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">lfp2</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp1_filt</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp2_filt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x1e28fb48c70&gt;]
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_27_1.png" src="_images/1_LFP_Coherence_Directionality_27_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lfp1_analytic</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">lfp1_filt</span><span class="p">)</span>
<span class="n">lfp2_analytic</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">lfp2_filt</span><span class="p">)</span>
<span class="n">xcorr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">lfp1_filt</span><span class="p">,</span> <span class="n">lfp2_filt</span><span class="p">)</span>
<span class="n">lags</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">correlation_lags</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lfp1_analytic</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lfp2_analytic</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">xcorr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Correlation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xcorr</span><span class="p">)],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Correlation is maximal where lag = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">xcorr</span><span class="p">)])</span><span class="o">+</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Correlation is maximal where lag = -10ms
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_28_1.png" src="_images/1_LFP_Coherence_Directionality_28_1.png" />
</div>
</div>
<p>The two signals are most correlated when the second signal is shifted backwards in time by 10ms, indicating the second signal lags the first by 10ms.</p>
</section>
<section id="phase-slope-index">
<h3>Phase Slope Index<a class="headerlink" href="#phase-slope-index" title="Permalink to this headline">#</a></h3>
<p>A second method to assess the directionality of information flow is the phase slope index (PSI) <a class="reference external" href="#References">[4]</a>. Phase is circular, and thus cannot indicate directionality in itself. However, taking the phase difference over a range of frequencies, one can begin to interpret directionality. PSI assumes one brain area interacts with another with some time offset, such that the speed at which different waves travel is similar. Since the same time difference will result in larger phase differences as frequency increases, there should be a positive slope in the phase spectrum. Therefore, PSI quantifies the slope of the phase spectrum, such that a positive slope indicates the first signal leads the second, and a negative signal indicates the reverse.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute PSI</span>
<span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span>
<span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp1</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">lfp2</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">minf</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">maxf</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minf</span><span class="p">,</span> <span class="n">maxf</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="n">freqs</span><span class="o">/</span><span class="mi">2</span>
<span class="c1"># con = mne_connectivity.SpectralConnectivity(epochs, n_nodes=2, freqs=np.arange(minf,maxf,2), method=&#39;cohy&#39;, indices=[np.asarray(0), np.asarray(1)])</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">mne_connectivity</span><span class="o">.</span><span class="n">phase_slope_index</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">minf</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">maxf</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Estimating phase slope index (PSI)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Connectivity computation...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for 1 connections
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using t=0.000s..1.999s for estimation (2000 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    frequencies: 60.0Hz..100.0Hz (81 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    Using multitaper spectrum estimation with 7 DPSS windows
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    the following metrics will be computed: Coherency
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Connectivity computation done]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Computing PSI from estimated Coherency: &lt;SpectralConnectivity | freq : [60.000000, 100.000000], , nave : 1, nodes, n_estimated : 2, 1, ~68 kB&gt;
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[PSI Estimation Done]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the relationship between phase difference and frequency</span>
<span class="n">con_complex</span> <span class="o">=</span> <span class="n">mne_connectivity</span><span class="o">.</span><span class="n">spectral_connectivity_epochs</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cohy&#39;</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="p">),</span>
                                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;cwt_morlet&#39;</span><span class="p">,</span> <span class="n">cwt_freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span>
                                                   <span class="n">cwt_n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
                                                   
<span class="n">coh_complex</span> <span class="o">=</span> <span class="n">con_complex</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="n">coh_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">coh_complex</span><span class="p">)</span>

<span class="c1">#Plot the phase slope for one timepoint</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">coh_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1000</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Phase offset (radians)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Connectivity computation...
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for 1 connections
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using t=0.000s..1.999s for estimation (2000 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    frequencies: 60.0Hz..98.0Hz (20 points)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    using CWT with Morlet wavelets to estimate spectra
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    the following metrics will be computed: Coherency
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>    computing connectivity for epoch 1
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Connectivity computation done]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Phase offset (radians)&#39;)
</pre></div>
</div>
<img alt="_images/1_LFP_Coherence_Directionality_32_9.png" src="_images/1_LFP_Coherence_Directionality_32_9.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[2.49877028]]
</pre></div>
</div>
</div>
</div>
<p>The slope of the phase offset by frequency graph is positive, leading to a positive PSI. This suggests lfp1 leads lfp2, as we know to be correct.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>Stoica, Petre, and Randolph Moses, “Spectral Analysis of Signals” Prentice Hall, 2005</p></li>
<li><p>Sandberg, J., &amp; Hansson, M. (2006). Coherence estimation between EEG signals using multiple window time-frequency analysis compared to Gaussian kernels. IEEE.</p></li>
<li><p>Hipp, J. F., Hawellek, D. J., Corbetta, M., Siegel, M., &amp; Engel, A. K. (2012). Large-scale cortical correlation structure of spontaneous oscillatory activity. Nature Neuroscience 2012 15:6, 15(6), 884–890. <a class="reference external" href="https://doi.org/10.1038/nn.3101">https://doi.org/10.1038/nn.3101</a></p></li>
<li><p>Nolte, G., Ziehe, A., Nikulin, V. V., Schlögl, A., Krämer, N., Brismar, T., &amp; Müller, K. R. (2008). Robustly estimating the flow direction of information in complex physical systems. Physical Review Letters, 100(23). <a class="reference external" href="https://doi.org/10.1103/PHYSREVLETT.100.234101">https://doi.org/10.1103/PHYSREVLETT.100.234101</a></p></li>
</ol>
</section>
</section>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"d2ccd8f6ad25441d8927a170208f16f6": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "106a26fb36fe4c1ba7f275dd973b2307": {"model_name": "ProgressStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ProgressStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "bar_color": null, "description_width": ""}}, "1a73f5c159b84cf482948a13daf4e0f2": {"model_name": "FloatProgressModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "FloatProgressModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ProgressView", "bar_style": "success", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_d2ccd8f6ad25441d8927a170208f16f6", "max": 3.0, "min": 0.0, "orientation": "horizontal", "style": "IPY_MODEL_106a26fb36fe4c1ba7f275dd973b2307", "value": 3.0}}, "e2102c89023f41baace2aecb199fbb83": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "b478c0efd6d2404b9e90fb128a2bc7f3": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "987b480cac98435c91c959729765a091": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_e2102c89023f41baace2aecb199fbb83", "placeholder": "\u200b", "style": "IPY_MODEL_b478c0efd6d2404b9e90fb128a2bc7f3", "value": "100%"}}, "41386bd59ad943fcbae21f64a2975cfb": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "7aed992e8a90475a8aa394086628dee5": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "c2a4607db94a44b7a3aeb171ba2520f1": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_41386bd59ad943fcbae21f64a2975cfb", "placeholder": "\u200b", "style": "IPY_MODEL_7aed992e8a90475a8aa394086628dee5", "value": "  : 3/3 [00:00&lt;00:00,   44.81it/s]"}}, "8ebfd5d67449457da05497f76409bdab": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "5462abe6ec564e37a1a489af10c8d686": {"model_name": "HBoxModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_987b480cac98435c91c959729765a091", "IPY_MODEL_1a73f5c159b84cf482948a13daf4e0f2", "IPY_MODEL_c2a4607db94a44b7a3aeb171ba2520f1"], "layout": "IPY_MODEL_8ebfd5d67449457da05497f76409bdab"}}}, "version_major": 2, "version_minor": 0}
</script>

<span id="document-2_ST_LFP_Spike_LFP_Coupling"></span><section class="tex2jax_ignore mathjax_ignore" id="spike-lfp-coupling">
<h2>Spike-LFP Coupling<a class="headerlink" href="#spike-lfp-coupling" title="Permalink to this headline">#</a></h2>
<p>Neural oscillations affect the spike timing of neurons. Identifying how neurons fire in relation to oscillations can help uncover which neurons participate in an oscillation, and and to what degree. This notebook will demonstrate how to quantify how the spike timing of neurons relates to underlying oscillations. Specifically, this notebook shows how to:</p>
<ol class="simple">
<li><p>Filter data into a frequency band</p></li>
<li><p>Extract phase information</p></li>
<li><p>Visualize spike-lfp coupling</p></li>
<li><p>Quantify spike-lfp coupling</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">butter</span><span class="p">,</span> <span class="n">filtfilt</span><span class="p">,</span> <span class="n">hilbert</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s start by simulating an oscillation, and a neuron that tends to fire at the trough of the oscillation. We’ll plot the spikes as vertical lines over the lfp.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Simulate LFP</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">lfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">lfp</span> <span class="o">+=</span> <span class="n">noise</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lfp</span><span class="p">)</span>
<span class="c1">#Simulate neuron</span>
<span class="n">spike_times</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lfp_min0</span> <span class="o">=</span> <span class="n">lfp</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lfp</span><span class="p">)</span><span class="o">+</span><span class="mf">.001</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)):</span>
    <span class="n">probability</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lfp_min0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">10</span>
    <span class="k">if</span> <span class="n">probability</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">probability</span><span class="p">,</span> <span class="n">probability</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sample</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">spike_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">spike_times</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">spike</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2_ST_LFP_Spike_LFP_Coupling_3_0.png" src="_images/2_ST_LFP_Spike_LFP_Coupling_3_0.png" />
</div>
</div>
<p>We’ll want to look at how the neuron fires with respect to some particular oscillation, or frequency band. To do so, we need to filter the lfp signal into a range of interest. Let’s start by filtering in the beta (12-32Hz) band.</p>
<section id="filtering-and-phase">
<h3>Filtering and Phase<a class="headerlink" href="#filtering-and-phase" title="Permalink to this headline">#</a></h3>
<p>Filtering is used to emphasize or demphasize activity in particular frequencies in time-series. Common applications of filters to neural electrophysiological data are to remove 60Hz line noise, remove low frequency activity for spike detection / remove high frequency activity for LFP analyses, and to isolate specific oscillations.</p>
<p>There are many commonly used filter designs, with customizable parameters. The goal of each filter is to maximize the attennuation of unwanted frequencies, which can be best achieved using filters with a narrow transition band in frequency space. However, these “sharp” filters produce stronger signal distortions and ringing artifacts. Therefore, choices in filter design often come down to this trade-off <a class="reference external" href="#References">[1]</a>. Additionally, higher filter orders effectively decrease the time resolution while increasing the frequency resolution. Here, we’ll use a butterworth filter, which is maximally uniform in how it affects the magnitude of activity in the filtered frequency range. Additionally, we’ll use an order of 4. Feel free to try other filter designs (cheby2, bessel) or orders to see their affects.</p>
<p>Filters are often applied through convolution over the signal. This can distort phase estimation, as convolving in a particular direction will result in a phase shift. To eliminate this shift, filters can be convolved once forwards and then backwards, which we will do with scipy’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html">filtfilt</a> function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span><span class="o">=</span><span class="mi">4</span>
<span class="n">freq_band</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>
<span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">freq_band</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
<span class="n">filt_data</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">lfp</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">filt_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x1e064233400&gt;]
</pre></div>
</div>
<img alt="_images/2_ST_LFP_Spike_LFP_Coupling_5_1.png" src="_images/2_ST_LFP_Spike_LFP_Coupling_5_1.png" />
</div>
</div>
<p>As you can see, we’ve removed a lot of the noise and cleanly uncovered the underlying oscillation.</p>
<p>Now we have extracted our oscillation, but we want to see whether the neuron’s spike timing is affected by this oscillation. One useful way to investigate this question is to look at whether the neuron tends to fire at some particular phase of the oscillation more than others. We therefore start by extracting the phase information for this oscillation. To get this, you use the hilbert transform to produce the analytic signal. This analytic signal is complex valued and contains both the instantaneous amplitude and phase information for our signal. The phase can be easily extracted by calling np.angle() function on the analytic signal.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">analytic_signal</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">filt_data</span><span class="p">)</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (degrees)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Phase (degrees)&#39;)
</pre></div>
</div>
<img alt="_images/2_ST_LFP_Spike_LFP_Coupling_7_1.png" src="_images/2_ST_LFP_Spike_LFP_Coupling_7_1.png" />
</div>
</div>
</section>
<section id="quantify-spike-lfp-coupling">
<h3>Quantify Spike LFP-Coupling<a class="headerlink" href="#quantify-spike-lfp-coupling" title="Permalink to this headline">#</a></h3>
<p>Now let’s try to see how the spike times of the neuron align to this beta oscillation. A good way to start is to create a histogram of these spike times by binning over their oscillation phase.</p>
<p>First, let’s collect the phases when the neuron spiked.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spike_phases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">spike_time</span> <span class="ow">in</span> <span class="n">spike_times</span><span class="p">:</span>
    <span class="n">spike_phases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike_time</span><span class="o">*</span><span class="n">fs</span><span class="p">))])</span>
</pre></div>
</div>
</div>
</div>
<p>To create the histogram, we then bin these spike phases using numpy’s digitize function, and then count up how many phases we have in each phase bin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_bins</span> <span class="o">=</span> <span class="mi">18</span>
<span class="n">phase_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">binned_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">,</span> <span class="n">phase_bins</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">spike_phase_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">spike_phase_hist</span><span class="p">[</span><span class="nb">bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binned_phases</span> <span class="o">==</span> <span class="nb">bin</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">spike_phase_hist</span><span class="p">)</span>

<span class="c1">#Plot</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">phase_bins</span><span class="p">,</span> <span class="n">spike_phase_hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">phase_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">phase_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bottom</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0. 10.  6.  7.  7.  3.  3.  0.  0.  0.  0.  0.  0.  1.  2.  4.  7.  3.
 15.]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;BarContainer object of 19 artists&gt;
</pre></div>
</div>
<img alt="_images/2_ST_LFP_Spike_LFP_Coupling_11_2.png" src="_images/2_ST_LFP_Spike_LFP_Coupling_11_2.png" />
</div>
</div>
<p>We can now see spikes are more likely to fire around 180 degrees phase, or the trough, of the oscillation. Let’s try to quantify the extent of this spike-phase coupling. To do so, I’ll use mean vector length, and pairwise phase coherence.</p>
<p><strong>Mean Vector length</strong></p>
<p>A common way to measure spike phase locking is to take the length of the mean vector of the spike-phase distribution <a class="reference external" href="#References">[2]</a>. If spikes are uniformally distributed with respect to phase, the mean of this distribution will be a point close to the center of the circle, and its radius will be close to 0. On the other hand, if spikes are clustered around some particular phase, the mean vector will point towards that phase and thus will have a radius closer to 1.</p>
<p>To calculate the mean vector length (mvl) of our distribution, we first need to map the spike phase distribution into polar coordinates and then take their mean. The mvl is then the distance of this point from (0,0).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">MVL</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">):</span>
    <span class="n">a_cos</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">spike_phases</span><span class="p">)</span>
    <span class="n">a_sin</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">spike_phases</span><span class="p">)</span>
    <span class="n">a_cos</span><span class="p">,</span> <span class="n">a_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">a_cos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">a_sin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> 
    <span class="n">uv_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a_cos</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">a_cos</span><span class="p">)</span>
    <span class="n">uv_y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a_sin</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">a_sin</span><span class="p">)</span>
    <span class="n">uv_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">uv_x</span><span class="o">*</span><span class="n">uv_x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">uv_y</span><span class="o">*</span><span class="n">uv_y</span><span class="p">))</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uv_radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uv_radius</span><span class="p">,</span> <span class="n">p_value</span>

<span class="n">vec_length</span><span class="p">,</span> <span class="n">pval</span> <span class="o">=</span> <span class="n">MVL</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean vector length: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">vec_length</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;, p value: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pval</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean vector length: 0.657, p value: 0.0
</pre></div>
</div>
</div>
</div>
<p>We get a p value of 0, indicating phase locking is highly significant.
However, this measure is highly dependent on the number of spikes in our sample <a class="reference external" href="#References">[3]</a>, as small samples will lead to a mean centered away from (0,0) even if spike phases are uniformally distributed.</p>
<p>One way to get around this is to repeatedly estimate the mvl on a surrogate spike phase distribution with the same number of samples as our actual sample, and estimate the difference between our real result and these surrogate estimates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_surrogates</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">sample_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span>
<span class="n">mvl_surrogates</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_surrogates</span>
<span class="k">for</span> <span class="n">surr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_surrogates</span><span class="p">):</span>
    <span class="n">spike_phases_surr</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">sample_size</span><span class="p">)</span> <span class="c1">#see note</span>
    <span class="n">mvl_surrogates</span><span class="p">[</span><span class="n">surr</span><span class="p">],</span> <span class="n">p</span> <span class="o">=</span> <span class="n">MVL</span><span class="p">(</span><span class="n">spike_phases_surr</span><span class="p">)</span>

<span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec_length</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mvl_surrogates</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mvl_surrogates</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">mvl_surrogates</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">vec_length</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">.6</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;Z-score: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">z_score</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.6, 20, &#39;Z-score: 9.70983737877545&#39;)
</pre></div>
</div>
<img alt="_images/2_ST_LFP_Spike_LFP_Coupling_15_1.png" src="_images/2_ST_LFP_Spike_LFP_Coupling_15_1.png" />
</div>
</div>
<p>The real mvl is clearly significantly higher than these surrogates, indicating spike-phase coupling is significant.</p>
<p><em>Note</em>: We could have randomly sampled from any number between -np.pi and np.pi, but instead I sampled from the actual observed phase values. This controls for a potential bias of spike-phase locking estimation, where not all phase values are observed in the oscillation itself. This occurs in smaller samples, where the length of the sample is less than a full cycle. If not all phases are observed, than the spike-phase distribution will be artificially non-uniform, and significant when compared to a surrogate distribution containing all possible phase values.</p>
<p><strong>Pairwise Phase Consistency</strong></p>
<p>Alternatively, another measure of spike-phase locking, pairwise phase consistency (ppc), is unbiased by the number of samples <a class="reference external" href="#References">[3]</a>. The measure computes the cosine of the angular distance between each pair of phases, resulting in an output of 1 for pairs of the same phase and -1 for antiphase pairs. After averaging across pairs, the measure will approach 0 for a uniform phase distribution and 1 for a perfectly aligned phase distribution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PPC</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">):</span>
    <span class="n">sp_complex</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">spike_phases</span><span class="p">)</span>
    <span class="n">all_com</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">sp_complex</span> <span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">dp_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">combination</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_com</span><span class="p">):</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">combination</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combination</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">dp_array</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span>
    <span class="n">dp_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dp_array</span><span class="p">)</span>
    <span class="n">ppc</span> <span class="o">=</span> <span class="n">dp_sum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ppc</span>
    
<span class="n">ppc_val</span> <span class="o">=</span> <span class="n">PPC</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PPC: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ppc_val</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PPC: 0.4230545209504523
</pre></div>
</div>
</div>
</div>
<p>The only disadvantage of using ppc over mvl is ppc, by computing the dot product between each possible phase pair, takes longer. Let’s illustrate that by measuring the time each function takes for a sample with 1000 phases.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spike_phases</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">)]</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">MVL</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span>
<span class="n">stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Vector Length process time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">PPC</span><span class="p">(</span><span class="n">spike_phases</span><span class="p">)</span>
<span class="n">stop</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pairwise Phase Consistency process time: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean Vector Length process time: 0.0
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Pairwise Phase Consistency process time: 1.453125
</pre></div>
</div>
</div>
</div>
<p>Clearly the PPC take significantly longer to compute. Though this time is still tolerable, or if you were to run ppc on many surrogate distributions (to capture the bias of the measure due to an incomplete phase distribution, for example), this time can add up. Therefore, when comparing with surrogate data, the mvl is more often used.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>Widmann, A., Schröger, E., &amp; Maess, B. (2015). Digital filter design for electrophysiological data – a practical approach. Journal of Neuroscience Methods, 250, 34–46. <a class="reference external" href="https://doi.org/10.1016/J.JNEUMETH.2014.08.002">https://doi.org/10.1016/J.JNEUMETH.2014.08.002</a></p></li>
<li><p>Canolty RT, Edwards E, Dalal SS, Soltani M, Nagarajan SS, Kirsch HE, et al. High Gamma Power Is Phase-Locked to Theta Oscillations in Human Neocortex. Science (80- ) [Internet]. 2006 Sep 15 [cited 2019 Aug 7];313(5793):1626–8. Available from: <a class="reference external" href="http://www.sciencemag.org/cgi/doi/10.1126/science.1128115">http://www.sciencemag.org/cgi/doi/10.1126/science.1128115</a></p></li>
<li><p>Vinck M, van Wingerden M, Womelsdorf T, Fries P, Pennartz CMA. The pairwise phase consistency: A bias-free measure of rhythmic neuronal synchronization. Neuroimage. 2010 May 15;51(1):112–22.</p></li>
</ol>
</section>
</section>
<span id="document-3_ST_SpikeTrain_Analyses"></span><section class="tex2jax_ignore mathjax_ignore" id="spike-train-analyses">
<h2>Spike Train Analyses<a class="headerlink" href="#spike-train-analyses" title="Permalink to this headline">#</a></h2>
<p>This tutorial will introduce analyses of neural spiking data, including identifying rhythmic activity in a neuron, and examining stimulus encoding by neural spike counts. Specifically, we will perform:</p>
<ol class="simple">
<li><p>Raster plot</p></li>
<li><p>Spike rate estimation using kernals</p></li>
<li><p>Autocorrelation</p></li>
<li><p>Power analyses of spike rate data (PSD, time-frequency power)</p></li>
<li><p>PCA visualization</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">elephant</span>
<span class="kn">from</span> <span class="nn">neo.core</span> <span class="kn">import</span> <span class="n">AnalogSignal</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">welch</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
</pre></div>
</div>
</div>
</div>
<p>First, we will simulate a neural spike train, an array of spike times for a neuron. For this and later analyses, we will use <a class="reference external" href="https://elephant.readthedocs.io/en/latest/index.html">elephant</a> <a class="reference external" href="#References">[1]</a>. Though elephant supports analyses of spike trains and LFP data, the package is particularly helpful for spike train analyses. For input, elephant often requires input data to be formatted using the <a class="reference external" href="#https://python-quantities.readthedocs.io/en/latest/">quantity</a> and <a class="reference external" href="#https://neo.readthedocs.io/en/stable/index.html">neo</a> packages: quantity allows the unit of measurement (seconds, milliseconds, Hz) to be tied to a numpy array, and neo supports electrophysological signal data objects, allowing data to be packaged with relevant information (such as the recorded time range of a spike train).</p>
<p>Here, we’ll simulate a spike train using elephant’s <a class="reference external" href="#https://elephant.readthedocs.io/en/latest/reference/spike_train_generation.html">spike_train_generation</a> module. We will use the inhomogeneous_poisson_process function, allowing us to specify a firing rate that fluctuates rhythmically at 20Hz.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate a neuron with an oscillating firing rate</span>

<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">mean_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">osc_rate</span> <span class="o">=</span> <span class="n">mean_rate</span> <span class="o">*</span> <span class="n">osc</span>
<span class="n">osc_rate</span> <span class="o">+=</span> <span class="n">mean_rate</span> <span class="c1">#make sure rate is always positive</span>
<span class="n">sim_spike_rate</span> <span class="o">=</span> <span class="n">AnalogSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">osc_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
<span class="n">spiketrain</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="raster-plot">
<h3>Raster plot<a class="headerlink" href="#raster-plot" title="Permalink to this headline">#</a></h3>
<p>The <em>spiketrain</em> output now contains an array of spike-times, which we can visualize using a raster plot. A raster plot visualizes spike times as vertical lines.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">osc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Input rate&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># plt.tick_params(bottom = False, labelbottom = False)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spikes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spikes</span><span class="p">),</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Output raster&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Time (s)&#39;)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Figure size 640x480 with 0 Axes&gt;
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_5_2.png" src="_images/3_ST_SpikeTrain_Analyses_5_2.png" />
</div>
</div>
</section>
<section id="spike-rate-estimation-using-kernel-density-estimation">
<h3>Spike rate estimation using kernel density estimation<a class="headerlink" href="#spike-rate-estimation-using-kernel-density-estimation" title="Permalink to this headline">#</a></h3>
<p>It is often useful to estimate how the spike rate of a neuron changes over time. A classical and effective method is kernel density estimation, where a kernel function is convolved with a spike train <a class="reference external" href="#References">[2]</a>. Common kernel functions include a gaussian kernel, which facilitates a smooth estimate of spike rate over time, or an exponential kernel, which can be used to prevent the smoothing of spike rate estimation backwards in time. Additionally, the user must decide the width of the kernel. Wider kernels smooth the spike rate estimation over longer periods of time (and thus risk smoothing over important changes in spike rate), while narrow kernels can produce noisy fluctuations in firing rate estimation. Here, I’ve selected a guassian kernel with a width (or standard deviation in time) of 5ms, where we can observe firing rate increase and decrease over the 20Hz (50ms cycle) rhythm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply a kernel to extract firing rate from spike train</span>

<span class="n">kernel_size</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">spike_sr</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">real_spike_rate</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                                   <span class="n">kernel</span><span class="o">=</span><span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">osc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Input rate&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spikes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spikes</span><span class="p">),</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Output raster&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">real_spike_rate</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Output rate&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Rate (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Rate (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_7_1.png" src="_images/3_ST_SpikeTrain_Analyses_7_1.png" />
</div>
</div>
</section>
<section id="rhythmicity">
<h3>Rhythmicity<a class="headerlink" href="#rhythmicity" title="Permalink to this headline">#</a></h3>
<p>Autocorrelation</p>
<p>Performing an autocorrelation on this spiketrain will allow us to capture the rhythmicity. Generally, an autocorrelation of a spike train computes the difference between the spike time of each spike with all other spike times in the spike train. If the neuron fires rhythmically, this will be reflected in the autocorrelation as an increased number of spikes at multiples of some time difference relative to 0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute autocorrelation of neuron</span>

<span class="c1"># spikes = [t.item() for t in spikes] #convert spiketrain into a list of spike times</span>

<span class="n">binsize</span> <span class="o">=</span> <span class="mf">.005</span>
<span class="n">histo_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">binsize</span><span class="p">)</span>
<span class="n">spike_diffs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spike1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spike2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">spike1</span><span class="o">==</span><span class="n">spike2</span><span class="p">:</span>
                <span class="n">spike_diffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike1</span> <span class="o">-</span> <span class="n">spike2</span><span class="p">)</span>
        
<span class="n">counts</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">spike_diffs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">histo_bins</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time lag (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Count&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_9_1.png" src="_images/3_ST_SpikeTrain_Analyses_9_1.png" />
</div>
</div>
<p>Here, we can see some rhythmicity in the comb-like appearence of the histogram, reflecting repeated time differences where spikes are more likely to occur. However, there is also a clear decrease in spike counts as the time differences increase. This is an artifact resulting from computing the autocorrelation at the beginning and end of the spike train. When comparing the time differences of other spikes relative to the first spike, time differences can only be positive, and for the last spike, time differences can be negative. Similarly, only spikes at the very beginning or end of the spike train can have a time difference with another spike close to 1. As we compute using spikes closer to the center of the spike train, the window of possible spike times increases, resulting in a linear increase in overall spike counts as time differences move closer to 0.</p>
<p>This artifact is really only relevant when computing auto-correlations on a short spike train, when the time differences of interest can approach the length of the spike train. Therefore, when computing an overall autocorrelation over the course of a recording, this will not be a problem, but when computing an autocorrelation over the course of a second or two (e.g. to see whether a stimulus induced rhythmicity), this affect will need to be addressed.</p>
<p>To remove this effect, establish the maximal time lag of interest. Then, we know which spikes to exclude: spikes that occur within the maximal lag of the start and end of the spike train.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute autocorrelation for only valid spikes</span>

<span class="c1"># spikes = [t.item() for t in spikes] #convert spiketrain into a list of spike times</span>

<span class="n">binsize</span> <span class="o">=</span> <span class="mf">.005</span>
<span class="n">max_lag</span> <span class="o">=</span> <span class="mf">.2</span>
<span class="n">start_win</span><span class="p">,</span> <span class="n">stop_win</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_lag</span>
<span class="n">histo_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_lag</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">binsize</span><span class="p">)</span>

<span class="n">spike_diffs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spike1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spike1</span><span class="o">&gt;</span><span class="n">start_win</span> <span class="ow">and</span> <span class="n">spike1</span><span class="o">&lt;</span><span class="n">stop_win</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spike2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">spike1</span><span class="o">==</span><span class="n">spike2</span><span class="p">:</span>
                    <span class="n">spike_diff</span> <span class="o">=</span> <span class="n">spike1</span> <span class="o">-</span> <span class="n">spike2</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spike_diff</span><span class="p">)</span><span class="o">&lt;</span><span class="n">max_lag</span><span class="p">:</span> 
                        <span class="n">spike_diffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike1</span> <span class="o">-</span> <span class="n">spike2</span><span class="p">)</span>
        
<span class="n">counts</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">spike_diffs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">histo_bins</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time lag (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Count&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_11_1.png" src="_images/3_ST_SpikeTrain_Analyses_11_1.png" />
</div>
</div>
<p>Here, we see peaks at -50 and 50 ms, and every multiple of that time lag, indicating rhythmic spiking every 50ms or 20Hz.</p>
<section id="power-metrics-of-spike-rate">
<h4>Power metrics of spike rate<a class="headerlink" href="#power-metrics-of-spike-rate" title="Permalink to this headline">#</a></h4>
<p>Analyses applied to quantify LFP oscillatory power can also be applied to the spike rate of our spike train <a class="reference external" href="#References">[3]</a>. Here, the kernel size must be chosen carefully, as a kernel smoothing the spike train over a long period of time will smear high frequency rhythmic activity, while smoothing over short periods of time can lead to a noisy signal. Here, we’ll analyze the power spectrum and time frequency power of the spike rate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sampling_period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">kernel_size</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1000</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">sampling_period</span><span class="p">))</span>
<span class="n">kernel_size</span> <span class="o">=</span> <span class="n">sampling_period</span>
<span class="n">kerneled_spike_rate</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                                   <span class="n">kernel</span><span class="o">=</span><span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">))</span>
<span class="n">kerneled_spike_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kerneled_spike_rate</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span><span class="n">kerneled_spike_rate</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span> <span class="c1">#select only frequencies below 100Hz</span>
<span class="n">Pxx</span> <span class="o">=</span> <span class="n">Pxx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Pxx</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Power Spectral Density&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_15_1.png" src="_images/3_ST_SpikeTrain_Analyses_15_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">ch_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span> <span class="n">sfreq</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">ch_types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;eeg&#39;</span><span class="p">])</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kerneled_spike_rate</span><span class="p">)))</span>
<span class="n">epoch</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">kerneled_spike_rate</span> <span class="c1">#Format data into [epochs, channels, samples] format</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">EpochsArray</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">n_cycles</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">tf_pow</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">time_frequency</span><span class="o">.</span><span class="n">tfr_morlet</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">freqs</span><span class="o">=</span><span class="n">freqs</span><span class="p">,</span> <span class="n">n_cycles</span><span class="o">=</span><span class="n">n_cycles</span><span class="p">,</span> <span class="n">return_itc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tf_pow</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf_pow</span><span class="o">.</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
           <span class="n">aspect</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">origin</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers.
[Parallel(n_jobs=1)]: Done   1 out of   1 | elapsed:    0.0s remaining:    0.0s
[Parallel(n_jobs=1)]: Done   1 out of   1 | elapsed:    0.0s finished
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Frequency (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_16_2.png" src="_images/3_ST_SpikeTrain_Analyses_16_2.png" />
</div>
</div>
<p>The power spectrum displays a strong peak at 20Hz, and the time-frequency representation shows some periods where 20Hz power is high. Overall, these methods are usually more effective when applied to LFP data, as the binary nature of neural spiking activity often results in noisy data. Still, these analyses can be useful in the absence of lfp data, or to analyze oscillatory activity individually in neurons.</p>
</section>
</section>
<section id="stimulus-encoding">
<h3>Stimulus encoding<a class="headerlink" href="#stimulus-encoding" title="Permalink to this headline">#</a></h3>
<p>A common step in electrophsiological experiments is to assess whether neural spiking activity can reflect stimulus information. To do so, we can start by plotting how individual neurons respond to different stimuli.</p>
<p>Let’s say we have a neuron responding to 4 stimuli, where the neuron’s response depends on the stimuli. Let’s make a raster plot, where different stimuli are plotted using different colors.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_stim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">n_units</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.prop_cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">by_key</span><span class="p">()[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>

<span class="c1"># Make a matrix of stimulus response rates</span>
<span class="n">response_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_units</span><span class="p">,</span> <span class="n">n_stim</span><span class="p">))</span>
<span class="n">max_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_units</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_stim</span><span class="p">):</span>
        <span class="n">response_rates</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_rate</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Simulate trials for each neuron and stimulus, and count spikes over a second period</span>
<span class="n">n_trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">matrix_defined</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">trial_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_stim</span><span class="p">):</span>
    <span class="n">response_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">n_units</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_trials</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_units</span><span class="p">):</span>
            <span class="n">spiketrain</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">StationaryPoissonProcess</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">response_rates</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
                                                                                  <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span><span class="o">.</span><span class="n">generate_spiketrain</span><span class="p">()</span>
            <span class="n">spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spikes</span><span class="p">,</span> <span class="n">trial_count</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">spikes</span><span class="p">),</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="n">trial_count</span><span class="o">+=</span><span class="mi">1</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Trial&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Trial&#39;)
</pre></div>
</div>
<img alt="_images/3_ST_SpikeTrain_Analyses_19_1.png" src="_images/3_ST_SpikeTrain_Analyses_19_1.png" />
</div>
</div>
<p>The neuron’s response rate should reflect the stimuli.</p>
<p>Now, what if we have 10 neurons, each with independent stimulus preferences. We’d like to be able to assess how these neurons could encode for stimuli as a population. However, we can’t effectively visualize the activity of 10 neurons over 10 trials and 4 stimuli. Instead, we can use principle component analysis (PCA) to reduce the activity of the population of neurons into 2 or 3 components.</p>
<section id="principle-component-analysis">
<h4>Principle Component Analysis<a class="headerlink" href="#principle-component-analysis" title="Permalink to this headline">#</a></h4>
<p>PCA reduces some features into a smaller number of components. In neuroscience, PCA is used to reduce the activity from some number of neurons into 2 or 3 components so that the data can be easily summarized and visualized. PCA works by iteratively finding the vector such that the projection of the data onto this vector best captures the variance in the data. The following vectors, or components, are then identified to capture the remaining variance in the data while being orthogonal to the previous components. Mathmatically, the fist step of PCA analysis is to compute the covariance matrix of the data. The components are then identified as the eigenvectors of the covariance matrix.</p>
<p>In interpreting the results of a PCA analysis, there are a few important points to remember. First, principle components are linear combinations of the initial variables: the actual output of a PCA decomposition is this weighting matrix, which must be multiplied with the original data to transform the data into PCA-space. Additionally, components are linearly uncorrelated with each other. Finally, since PCA iteratively captures as much variance as possible with each component, each subsequent component will capture less variance than the previous component <a class="reference external" href="#References">[4]</a>.</p>
<p>In sklearn’s PCA function, the input matrix needs to be formatted such that the first dimension corresponds to each sample, and the second corresponds to each feature (here, neuron). We want to input all of our trials, regardless of the stimulus, into sklearn (but be able to organize by stimulus later), so here we’ll stack trials from different stimuli along the first dimension, creating a matrix that is (n_stim x n_trials) by n_units.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_stim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">n_units</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Make a matrix of stimulus response rates</span>
<span class="n">response_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_units</span><span class="p">,</span> <span class="n">n_stim</span><span class="p">))</span>
<span class="n">max_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_units</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_stim</span><span class="p">):</span>
        <span class="n">response_rates</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_rate</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Simulate trials for each neuron and stimulus, and count spikes over a second period</span>
<span class="n">n_trials</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">matrix_defined</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_stim</span><span class="p">):</span>
    <span class="n">response_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">n_units</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_trials</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_units</span><span class="p">):</span>
            <span class="n">spiketrain</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">StationaryPoissonProcess</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">response_rates</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
                                                                                  <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span><span class="o">.</span><span class="n">generate_spiketrain</span><span class="p">()</span>
            <span class="n">response_counts</span><span class="p">[</span><span class="n">trial</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">matrix_defined</span><span class="p">:</span>
        <span class="n">feature_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">feature_matrix</span><span class="p">,</span> <span class="n">response_counts</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">feature_matrix</span> <span class="o">=</span> <span class="n">response_counts</span>
        <span class="n">matrix_defined</span> <span class="o">=</span> <span class="kc">True</span>
        
<span class="n">feature_matrix</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(40, 10)
</pre></div>
</div>
</div>
</div>
<p>We can then perform PCA decomposition on this matrix, and plot the newly reduced dataset by which stimuli the trials came from.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Decompose data using PCA</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">)</span>

<span class="c1">#Plot PCA</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="s2">&quot;3d&quot;</span><span class="p">})</span>

<span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">rainbow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_stim</span><span class="p">))</span>
<span class="k">for</span> <span class="n">stim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_stim</span><span class="p">):</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">stim</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">stim</span><span class="o">*</span><span class="n">n_trials</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">stim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_trials</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">pc1_mean</span><span class="p">,</span> <span class="n">pc2_mean</span><span class="p">,</span> <span class="n">pc3_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">pc1_sem</span><span class="p">,</span> <span class="n">pc2_sem</span><span class="p">,</span> <span class="n">pc3_sem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># the angle of the projection in the xy-plane</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">256</span><span class="p">)</span>  <span class="c1"># the angle from the polar axis, ie the polar angle</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pc1_sem</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">pc1_mean</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pc2_sem</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">pc2_mean</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">pc3_sem</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">pc3_mean</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                       <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/3_ST_SpikeTrain_Analyses_23_0.png" src="_images/3_ST_SpikeTrain_Analyses_23_0.png" />
</div>
</div>
<p>The stimuli are clearly separated in PCA space.</p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>Denker M, Yegenoglu A, Grün S (2018) Collaborative HPC-enabled workflows on the HBP Collaboratory using the Elephant framework. Neuroinformatics 2018, P19. doi:10.12751/incf.ni2018.0019</p></li>
<li><p>Sanderson, A. C. (1980). Adaptive filtering of neuronal spike train data. IEEE Transactions on Bio-Medical Engineering, 27(5), 271–274. <a class="reference external" href="https://doi.org/10.1109/TBME.1980.326633">https://doi.org/10.1109/TBME.1980.326633</a></p></li>
<li><p>Burton, S. D., &amp; Urban, N. N. (2021). Cell and circuit origins of fast network oscillations in the mammalian main olfactory bulb. ELife, 10. <a class="reference external" href="https://doi.org/10.7554/ELIFE.74213">https://doi.org/10.7554/ELIFE.74213</a></p></li>
<li><p>Hastie, T. et. all. (2009). Springer Series in Statistics The Elements of Statistical Learning. In The Mathematical Intelligencer (Vol. 27, Issue 2). <a class="reference external" href="http://www.springerlink.com/index/D7X7KX6772HQ2135.pdf">http://www.springerlink.com/index/D7X7KX6772HQ2135.pdf</a></p></li>
</ol>
</section>
</section>
<span id="document-4_ST_Spike_Synchrony"></span><section class="tex2jax_ignore mathjax_ignore" id="spike-synchrony">
<h2>Spike Synchrony<a class="headerlink" href="#spike-synchrony" title="Permalink to this headline">#</a></h2>
<p>Neural synchronization can facilitate information transfer and the binding of information. Many methods have been employed to quantify nerual synchrony, and no one technique has become widely viewed as the gold-standard. Here, I will illustrate several methods to quantify neural synchrony, specifically:</p>
<ol class="simple">
<li><p>Cross correlation</p></li>
<li><p>Unitary event analysis</p></li>
<li><p>Spike-triggered population rate</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">elephant</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">from</span> <span class="nn">neo.core</span> <span class="kn">import</span> <span class="n">AnalogSignal</span>
<span class="kn">from</span> <span class="nn">neo</span> <span class="kn">import</span> <span class="n">SpikeTrain</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">quantities</span> <span class="k">as</span> <span class="nn">pq</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">viziphant.unitary_event_analysis</span> <span class="k">as</span> <span class="nn">vue</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">binom</span>
<span class="kn">from</span> <span class="nn">seaborn</span> <span class="kn">import</span> <span class="n">color_palette</span>
</pre></div>
</div>
</div>
</div>
<p>First, let’s simulate 2 neurons, synchronized to the same underlying oscillation. Here, we can model this by generating two spike trains from the same underlying rhythmic firing rate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1224</span><span class="p">)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">mean_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">osc_rate</span> <span class="o">=</span> <span class="n">mean_rate</span> <span class="o">*</span> <span class="n">osc</span>
<span class="n">osc_rate</span> <span class="o">+=</span> <span class="n">mean_rate</span> <span class="c1">#make sure rate is always positive</span>
<span class="n">sim_spike_rate</span> <span class="o">=</span> <span class="n">AnalogSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">osc_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
<span class="n">st1</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
<span class="n">st2</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="cross-correlation">
<h3>Cross correlation<a class="headerlink" href="#cross-correlation" title="Permalink to this headline">#</a></h3>
<p>Generating a cross correleogram is a good first step for assessing possible synchrony between neurons. A cross correlelogram shows the approximate timescale of this synchrony, as well as the rhythm that gives rise to the synchrony. Additionally, a cross correlation is relatively straightforward and common to compute. For more details, see the section on <strong>autocorrelation</strong> in <em>spiketrain_analyses</em>. This is the same analysis, but instead of comparing a spike train with itself, here we’re comparing two spike trains.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spikes1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
<span class="n">spikes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>

<span class="n">binsize</span> <span class="o">=</span> <span class="mf">.005</span>
<span class="n">max_lag</span> <span class="o">=</span> <span class="mf">.1</span>
<span class="n">start_win</span><span class="p">,</span> <span class="n">stop_win</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_lag</span>
<span class="n">histo_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">max_lag</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">binsize</span><span class="p">)</span>

<span class="n">spike_diffs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spike1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spike1</span><span class="o">&gt;</span><span class="n">start_win</span> <span class="ow">and</span> <span class="n">spike1</span><span class="o">&lt;</span><span class="n">stop_win</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">spike2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spikes2</span><span class="p">):</span>
                <span class="n">spike_diff</span> <span class="o">=</span> <span class="n">spike1</span> <span class="o">-</span> <span class="n">spike2</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spike_diff</span><span class="p">)</span><span class="o">&lt;</span><span class="n">max_lag</span><span class="p">:</span> 
                    <span class="n">spike_diffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike1</span> <span class="o">-</span> <span class="n">spike2</span><span class="p">)</span>
        
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">counts</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">spike_diffs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">histo_bins</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time lag (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Count&#39;)
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_5_1.png" src="_images/4_ST_Spike_Synchrony_5_1.png" />
</div>
</div>
<p>The bin at time lag = 0 can be used to assess synchronization. Here, the spike count at 0 is greater than the overall mean, suggesting these neurons are synchronous.</p>
</section>
<section id="unitary-event-analysis">
<h3>Unitary event analysis<a class="headerlink" href="#unitary-event-analysis" title="Permalink to this headline">#</a></h3>
<p>Unitary event analysis essentially computes the number of synchronous spikes <a class="reference external" href="#References">[1]</a>. Because some number of synchronous spikes are expected by chance, this number is then compared to an ‘expected’ number of spikes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute number of synchronous spikes</span>
<span class="n">binned_st1</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">conversion</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="c1">#Binarize spike train</span>
<span class="n">binned_st2</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">conversion</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="c1">#Binarize spike train</span>

<span class="n">sync_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">(),</span><span class="n">binned_st2</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">())</span> <span class="c1">#Find where spikes occurred in both spiketrains</span>
<span class="n">n_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sync_events</span><span class="p">)</span>
<span class="n">n_bins</span> <span class="o">=</span> <span class="n">sync_events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of bins: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_bins</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of synchronous events: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_events</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of bins: 400
Number of synchronous events: 43
</pre></div>
</div>
</div>
</div>
<p>Now, let’s compare this number with how much we would expect by chance. There are a few ways to compute this. Analytically,  we have two spike trains with a mean rate of 60Hz. Therefore, each neuron spikes .3 times per 5ms, and for any 5ms bin, the probability of both neurons spiking is .09. We can calculate the probability that we observe 43 synchronous events or greater using a binomial distribution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Analytic</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">binom</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">,</span> <span class="mf">.09</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Analytic probability: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Analytic probability: 0.09754615335115961
</pre></div>
</div>
</div>
</div>
<p>Though simple and efficient, this method works only when the firing rate of neurons is stationary over time. However, the firing rate of neurons can change over time, in ways that are correlated with one another that may be spurious to this analysis. This can occur with the onset of a stimulus, or a neuromodulator.</p>
<p>To deal with non-stationarities, there are several methods to create surrogate spike trains, which the actual number of synchronous events can be compared with <a class="reference external" href="#References">[2]</a>. Surrogates are commonly created by dithering (or jittering) a spike train by randomly moving each spike by some time within some small time frame. Alternatively, surrogates can be created by randomly shifting spike trains against each other, conserving the original structure of each spike train but requiring ultimately large time shifts. When analyzing synchrony evoked by a stimulus, spike trains can be shifted across trials, such that the number of synchronous events can be compared with the number of synchronous events found when comparing neurons recorded in different trials. However, this analysis assumes stationarity can be assumed across trials, which is generally unlikely.</p>
<p>Here, let’s dither to create surrogate spike trains, and compare the actual number of synchronous events with this distribution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare with surrogate spike trains</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2022</span><span class="p">)</span>
<span class="n">surr_evts</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">surr_sts</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_surrogates</span><span class="o">.</span><span class="n">dither_spikes</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">n_surrogates</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="k">for</span> <span class="n">surr_st</span> <span class="ow">in</span> <span class="n">surr_sts</span><span class="p">:</span>
    <span class="n">binned_surr_st</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">conversion</span><span class="o">.</span><span class="n">BinnedSpikeTrain</span><span class="p">(</span><span class="n">surr_st</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span> <span class="c1">#Binarize spike train</span>
    <span class="n">sync_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">binned_st1</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">(),</span><span class="n">binned_surr_st</span><span class="o">.</span><span class="n">to_bool_array</span><span class="p">())</span> <span class="c1">#Find where spikes occurred in both spiketrains</span>
    <span class="n">surr_evts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sync_events</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\Michael\anaconda3\envs\tutorials\lib\site-packages\quantities\quantity.py:337: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return np.multiply(other, self)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">surr_evts</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# synchronous events&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">n_events</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;Actual # events&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_events</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">surr_evts</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">surr_evts</span><span class="p">)</span>

<span class="n">dith_p</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">z_score</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dithered probability: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dith_p</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dithered probability: 0.10832211715896994
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_13_1.png" src="_images/4_ST_Spike_Synchrony_13_1.png" />
</div>
</div>
<p>Now, let’s simulate two spike trains that only become synchronous after 1s.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2022</span><span class="p">)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">mean_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">osc_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">))</span>
<span class="n">osc_rate</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span> <span class="o">=</span> <span class="n">mean_rate</span> <span class="o">*</span> <span class="n">osc</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">osc_rate</span> <span class="o">+=</span> <span class="n">mean_rate</span> <span class="c1">#make sure rate is always positive</span>
<span class="n">sim_spike_rate</span> <span class="o">=</span> <span class="n">AnalogSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">osc_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
<span class="n">st1</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
<span class="n">st2</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can calculate how synchrony changes over time using elephant’s jointJ_window_analysis function, and plot it using the plot_ue function from viziphant (elephant’s companion visualization package).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spiketrains</span> <span class="o">=</span> <span class="p">[[</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">]]</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2022</span><span class="p">)</span>
<span class="n">UEs</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">unitary_event_analysis</span><span class="o">.</span><span class="n">jointJ_window_analysis</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">500</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">winstep</span><span class="o">=</span><span class="mi">50</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">pattern_hash</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">vue</span><span class="o">.</span><span class="n">plot_ue</span><span class="p">(</span><span class="n">spiketrains</span><span class="p">,</span> <span class="n">UEs</span><span class="p">,</span> <span class="n">significance_level</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>FigureUE(axes_spike_events=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Spike Events&#39;}, ylabel=&#39;Trial&#39;&gt;, axes_spike_rates=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Spike Rates&#39;}, ylabel=&#39;Hz&#39;&gt;, axes_coincident_events=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Coincident Events&#39;}, ylabel=&#39;Trial&#39;&gt;, axes_coincidence_rates=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Coincidence Rates&#39;}, ylabel=&#39;Hz&#39;&gt;, axes_significance=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Statistical Significance&#39;}&gt;, axes_unitary_events=&lt;AxesSubplot: title={&#39;center&#39;: &#39;Unitary Events&#39;}, xlabel=&#39;Time (ms)&#39;, ylabel=&#39;Trial&#39;&gt;)
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_18_1.png" src="_images/4_ST_Spike_Synchrony_18_1.png" />
</div>
</div>
<p>Elephant’s visualization shows many coincident events. Additionally, the actual coincidence rate is generally higher than the expected, as calculated analytically. However, the windows only reach significance around 1s, and only coincident events in these windows are marked as unitary events.</p>
</section>
<section id="spike-triggered-population-rate">
<h3>Spike-triggered population rate<a class="headerlink" href="#spike-triggered-population-rate" title="Permalink to this headline">#</a></h3>
<p>Alternatively, spike-spike synchrony can be computed as the spike-triggered population rate (stPR), or the firing rate of other neurons when one neuron fires <a class="reference external" href="#References">[3]</a>. This method has several advantages. First, the method can be used to test the synchrony between one neuron and a population of neurons. Therefore, when analyzing the general synchrony of each neuron, rather than neuron synchrony between individual neurons, this method can be much more efficient. Additionally, as demonstrated later, this method does not require the generation of surrogate neural spiketrains to control for a non-stationarity spikerate. As a result, this method can be much more computationally efficient in analyzing the neural synchrony between a neuron and a population of neurons. Finally, this method provides a synchrony value for each spike, rather than for a given window of time, allowing for finer time resolution in analyzing synchrony.</p>
<p>To illustrate this method, we’ll start off by simulating a neuron, and a neural population, each firing in a synchronized rhythm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Simulate a neuron, and a neural population</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2022</span><span class="p">)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">mean_rate</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">osc_rate</span> <span class="o">=</span> <span class="n">mean_rate</span> <span class="o">*</span> <span class="n">osc</span>
<span class="n">osc_rate</span> <span class="o">+=</span> <span class="n">mean_rate</span> <span class="c1">#make sure rate is always positiv</span>
<span class="n">sim_spike_rate</span> <span class="o">=</span> <span class="n">AnalogSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">osc_rate</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
<span class="n">st2</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

<span class="n">n_pop_neurons</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">st_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">))</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_pop_neurons</span><span class="p">):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_generation</span><span class="o">.</span><span class="n">inhomogeneous_poisson_process</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="n">sim_spike_rate</span><span class="p">,</span> <span class="n">refractory_period</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="n">st_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">st_pop</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
    
<span class="n">st_pop</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st_pop</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">))</span>   
</pre></div>
</div>
</div>
</div>
<p>Then, calculate the stPR, the mean firing rate of the population when neuron 2 fires.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Calculate stPR (uncorrected)</span>
<span class="n">spike_sr</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">st_pop</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                              <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">center_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span> <span class="o">/</span> <span class="n">n_pop_neurons</span>
<span class="n">stPRs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">spikes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">spikes2</span><span class="p">:</span>
    <span class="n">stPRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">rate</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike</span> <span class="o">*</span> <span class="n">spike_sr</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]))</span>
    
<span class="n">mean_stPR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stPRs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean firing rate: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rate</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean stPR: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mean_stPR</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">))</span>    
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean firing rate: 59.576873252977244 Hz
Mean stPR: 66.67997370011862 Hz
</pre></div>
</div>
</div>
</div>
<p>The spike-triggered firing rate is greater than the overall mean firing rate, meaning neuron 2 is more likely to fire around when neurons in the population are firing relatively more.</p>
<p>Additionally, for each spike, we can get the firing rate in a surrounding window of time. This will allow us to see at what timescale the firing rate of neuron 1 increases when neuron 2 fires.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spike_sr</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">window</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">st_pop</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                              <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">center_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span> <span class="o">/</span> <span class="n">n_pop_neurons</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
<span class="n">stPR_segs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">spikes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">spikes2</span><span class="p">:</span>
    <span class="n">spike</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spike</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spike</span> <span class="o">&gt;</span> <span class="n">window</span><span class="o">/</span><span class="n">spike_sr</span> <span class="ow">and</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">spike</span> <span class="o">&gt;</span> <span class="n">window</span><span class="o">/</span><span class="n">spike_sr</span><span class="p">:</span> <span class="c1">#If window entirely within times analyzed</span>
        <span class="n">rate_seg</span> <span class="o">=</span> <span class="n">rate</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike</span><span class="o">*</span><span class="n">spike_sr</span><span class="p">))</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike</span><span class="o">*</span><span class="n">spike_sr</span><span class="p">))</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">stPR_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rate_seg</span><span class="p">)</span>
    
<span class="n">stPRs_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">stPR_segs</span><span class="p">)</span>
<span class="n">stPRs_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stPRs_arr</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">window</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">window</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stPRs_arr</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time lag (ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Population firing rate (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Population firing rate (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_25_1.png" src="_images/4_ST_Spike_Synchrony_25_1.png" />
</div>
</div>
<p>We have essentially created a cross correlation figure, using the firing rate of unit 1.</p>
<p>However, this method is biased by the mean firing rate of the population: if neurons fire more in general, the stPR will be higher. Thus, just as with unitary event analysis, we need to find a method to control for the overall firing rate of the population.</p>
<p>In the original paper for this method, the authors did so via a shuffling method. Though their exact method does not suit our data, we can implement something similar by comparing with surrogate spike trains as we did before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Surrogate vs. real stPR</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2022</span><span class="p">)</span>
<span class="n">surr_stPRs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">surr_sts</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">spike_train_surrogates</span><span class="o">.</span><span class="n">dither_spikes</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="n">n_surrogates</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="k">for</span> <span class="n">surr_st</span> <span class="ow">in</span> <span class="n">surr_sts</span><span class="p">:</span>
    <span class="n">stPRs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">surr_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">surr_st</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">surr_spikes</span><span class="p">:</span>
        <span class="n">stPRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">rate</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike</span> <span class="o">*</span> <span class="n">spike_sr</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]))</span>
    <span class="n">surr_stPRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stPRs</span><span class="p">))</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">surr_stPRs</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">mean_stPR</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;stPR&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">mean_stPR</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;Actual stPR&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_stPR</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">surr_stPRs</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">surr_stPRs</span><span class="p">)</span>

<span class="n">dith_p</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">z_score</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dithered probability: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dith_p</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dithered probability: 3.5099805001481054e-08
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_28_1.png" src="_images/4_ST_Spike_Synchrony_28_1.png" />
</div>
</div>
<p>Alternatively, we can control for the overall firing rate of the population (and its nonstationarities) in our measurement of the firing rate itself. We can isolate the fine-timescale deviations from the mean firing rate by substracting out the longer-timescale estimate of firing rate. Specifically, this method measures firing rate on a fine time-scale using a narrow kernel, and subtracts the firing rate measured on a slow timescale from this firing rate.</p>
<p>First, let’s isolate the fine-timescale fluctuations of the population by substracting out a longer-timescale estimate of firing rate. We’ll add a simulation of a slow fluctuation in firing rate, to illustrate how we can remove it with this analysis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Isolate fine-timescale firing rate fluctuations</span>
<span class="n">fast_kernel_sigma</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">slow_kernel_sigma</span> <span class="o">=</span> <span class="mi">11</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">fastk</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">fast_kernel_sigma</span><span class="p">)</span>
<span class="n">slowk</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">slow_kernel_sigma</span><span class="p">)</span>

<span class="n">fast_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">st_pop</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                                       <span class="n">kernel</span><span class="o">=</span><span class="n">fastk</span><span class="p">,</span> <span class="n">center_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">slow_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">elephant</span><span class="o">.</span><span class="n">statistics</span><span class="o">.</span><span class="n">instantaneous_rate</span><span class="p">(</span><span class="n">st_pop</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">spike_sr</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
                                                       <span class="n">kernel</span><span class="o">=</span><span class="n">slowk</span><span class="p">,</span> <span class="n">center_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">fast_rate</span> <span class="o">/=</span> <span class="n">n_pop_neurons</span>
<span class="n">slow_rate</span> <span class="o">/=</span> <span class="n">n_pop_neurons</span>
<span class="n">fast_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">fast_rate</span><span class="p">)</span>
<span class="n">slow_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">slow_rate</span><span class="p">)</span>
<span class="n">freq</span><span class="o">=</span><span class="mi">1</span>
<span class="n">osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">times</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="n">fast_rate</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">osc</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span> <span class="c1">#Add general drift to the firing rates</span>
<span class="n">slow_rate</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">osc</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span> <span class="c1">#Add general drift to the firing rates</span>
<span class="n">diff_rate</span> <span class="o">=</span> <span class="n">fast_rate</span> <span class="o">-</span> <span class="n">slow_rate</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;flare&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">fast_rate</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fast rate&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">slow_rate</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;slow rate&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">diff_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;fast - slow&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing rate (Hz)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Firing rate (Hz)&#39;)
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_30_1.png" src="_images/4_ST_Spike_Synchrony_30_1.png" />
</div>
</div>
<p>The fine-timescale kernel firing rate tracks the high frequency oscillation, while the slow-timescale kernel does not. Still, the slow kernel tracks the non-stationary firing rate. Substracting this from the fast kernel removes the slower drift in our data. Now, firing rate has a mean of 0, and positive values indicate a relative increase in firing rate, while negative values indicate the reverse. Now, we can calculate the stPR on this difference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stPRs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">spikes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">spikes2</span><span class="p">:</span>
    <span class="n">stPRs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">diff_rate</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">spike</span> <span class="o">*</span> <span class="n">spike_sr</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]))</span>
    
<span class="n">mean_stPR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stPRs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean firing rate: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff_rate</span><span class="p">)</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean stPR: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mean_stPR</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">Hz</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean firing rate: 0.18442787923700246 Hz
Mean stPR: 16.170752011037074 Hz
</pre></div>
</div>
</div>
</div>
<p>The stPR is much higher than 0, indicating the neuron is synchronous with the population. Notably, unlike the other methods, this analysis does not provide a significance value. Still, these values can be compared between neurons, or with a baseline.</p>
</section>
<section id="kernel-design">
<h3>Kernel design<a class="headerlink" href="#kernel-design" title="Permalink to this headline">#</a></h3>
<p>We can get a more exact idea of what firing rate changes this timescale is estimating by plotting how each kernel estimates the firing rate of a single spike.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Kernel design</span>
<span class="n">fast_kernel_sigma</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">slow_kernel_sigma</span> <span class="o">=</span> <span class="mi">11</span><span class="o">*</span><span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">spiketrain</span> <span class="o">=</span> <span class="n">SpikeTrain</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">t_start</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="n">time_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1001</span><span class="p">)</span> <span class="o">*</span> <span class="n">pq</span><span class="o">.</span><span class="n">ms</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">fast_kernel_sigma</span><span class="p">)</span>
<span class="n">fast_kernel_time</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">elephant</span><span class="o">.</span><span class="n">kernels</span><span class="o">.</span><span class="n">GaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">slow_kernel_sigma</span><span class="p">)</span>
<span class="n">slow_kernel_time</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>


<span class="n">colors</span> <span class="o">=</span> <span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;flare&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">fast_kernel_time</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">slow_kernel_time</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">fast_kernel_sigma</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; kernel&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">slow_kernel_sigma</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; kernel&#39;</span><span class="p">,</span> <span class="s1">&#39;Difference&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;time, ms&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;kernel, 1/ms&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">fast_kernel_time</span><span class="o">-</span><span class="n">slow_kernel_time</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;time, ms&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;kernel, 1/ms&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Difference&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x1d02aca3610&gt;
</pre></div>
</div>
<img alt="_images/4_ST_Spike_Synchrony_35_1.png" src="_images/4_ST_Spike_Synchrony_35_1.png" />
</div>
</div>
<p>The narrower kernel results in an estimatation of firing rate that only increases immediately surrounding the spike, but increases to a much higher degree. Specifically, using a 3ms and 11ms sigma for the fine and slow time-scale kernels, respectively, the fine-timescale firing rate is increased in the 10ms surrounding the spike, but decreased in the remaining 60ms. Therefore, this metric will be positive when the difference between two spike times is less than 5ms, or negative when the difference is between 5 and ~30ms.</p>
<p>Using this method, the timescales of the kernels should be carefully designed to reflect what the study would like to define as synchrony, and what general fluctuations should be removed.</p>
</section>
<section id="convolution-of-a-cross-correlation">
<h3>Convolution of a cross correlation<a class="headerlink" href="#convolution-of-a-cross-correlation" title="Permalink to this headline">#</a></h3>
<p>Other studies have convolved the cross correlation histogram, rather than the spike trains themselves, to estimate synchrony. Specifically, after a cross correlelogram has been computed, slower covariations in firing rate are estimated by convolving the cross correlelogram with a gaussian kerenel. The significance of each bin can then be compared to the convolved correlelogram, asssuming a poisson distribution <a class="reference external" href="#References">[4]</a>. This method therefore allows for the estimation of significance without jittering. Additionally, this method can also be applied towards identifying peaks in the cross correlelogram at time lags other than 0, for example, to identify a monosynaptic connection between neurons from a peak at +3ms <a class="reference external" href="#References">[5]</a>. However, the time resolution of this method is limited, as a cross correlelogram must be computed with a sufficent time window to include a reasonable estimate of the distribution at various time lags. This method has not been used by our lab, but the Buzsaki lab has published <a class="reference external" href="#https://github.com/AntonioFR8/buzcodeAFR/blob/devAFR/analysis/monosynapticPairs/bz_GetMonoSynapticallyConnected.m">example code</a> on Github.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>Grün, S., Diesmann, M., Grammont, F., Riehle, A., &amp; Aertsen, A. (1999). Detecting unitary events without discretization of time. Journal of neuroscience methods, 94(1), 67-79</p></li>
<li><p>Grün, S. (2009). Data-driven significance estimation for precise spike correlation. Journal of Neurophysiology, 101(3), 1126–1140. <a class="reference external" href="https://doi.org/10.1152/JN.00093.2008/ASSET/IMAGES/LARGE/Z9K0030993390009.JPEG">https://doi.org/10.1152/JN.00093.2008/ASSET/IMAGES/LARGE/Z9K0030993390009.JPEG</a></p></li>
<li><p>Okun, M., Steinmetz, N. A., Cossell, L., Iacaruso, M. F., Ko, H., Barthó, P., Moore, T., Hofer, S. B., Mrsic-Flogel, T. D., Carandini, M., &amp; Harris, K. D. (2015). Diverse coupling of neurons to populations in sensory cortex. Nature, 521(7553), 511. <a class="reference external" href="https://doi.org/10.1038/NATURE14273">https://doi.org/10.1038/NATURE14273</a></p></li>
<li><p>Stark, E., &amp; Abeles, M. (2009). Unbiased estimation of precise temporal correlations between spike trains. Journal of Neuroscience Methods, 179(1), 90–100. <a class="reference external" href="https://doi.org/10.1016/J.JNEUMETH.2008.12.029">https://doi.org/10.1016/J.JNEUMETH.2008.12.029</a></p></li>
<li><p>English, D. F., McKenzie, S., Evans, T., Kim, K., Yoon, E., &amp; Buzsáki, G. (2017). Pyramidal cell-interneuron circuit architecture and dynamics in hippocampal networks. Neuron, 96(2), 505. <a class="reference external" href="https://doi.org/10.1016/J.NEURON.2017.09.033">https://doi.org/10.1016/J.NEURON.2017.09.033</a></p></li>
</ol>
</section>
</section>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Michael Mariscal<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>